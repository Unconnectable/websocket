### 1. 项目技术规划

| 核心组件        | 技术选型                                   | 优点                                                                         | 缺点                                                          |
| :-------------- | :----------------------------------------- | :--------------------------------------------------------------------------- | :------------------------------------------------------------ |
| **后端服务**    | **Tokio (Rust)**                           | 高性能、内存安全、并发模型强大、生态成熟。                                   | 异步编程心智负担较重，学习曲线相对陡峭。                      |
| **通信协议**    | **JSON over TCP** (长度前缀分帧)           | 人类可读，调试方便，生态广泛 (`serde_json`)。                                | 性能不如二进制协议，存在一定的冗余数据。                      |
| **持久化层**    | **自研日志结构存储** (使用`bincode`序列化) | **深入理解数据库原理**，完美契合聊天记录等写入密集场景，无外部依赖。         | 实现复杂（事务、索引、崩溃恢复），非生产级可靠性。            |
| **内核观测**    | **Aya (纯 Rust eBPF 框架)**                | **纯 Rust 开发，无需 C 依赖**，性能极高，实现无侵入式底层监控。              | 学习门槛高，强依赖较新 Linux 内核，内核态程序调试困难。       |
| **前端/仪表盘** | **Tauri (Rust + Webview)**                 | **高性能、应用体积小**，可利用成熟 Web 技术栈构建 UI，与 Rust 后端无缝集成。 | 生态不如 Electron 成熟，依赖系统 WebView 可能存在兼容性差异。 |

---

### 2. 全新发展路线

这个路线将项目视为一个完整的系统，而非仅仅一个聊天应用。每一步都为最终的整合目标服务。

#### **第一步：定义“系统契约” - 升级到结构化协议**

这是所有后续工作的基础，是系统各组件间通信的通用语言。

- **目标：** 抛弃 `read_line`，实现基于 JSON 的、有明确边界的请求-响应模型。
- **行动：**
  1.  **定义消息体：** 创建 `src/protocol.rs`，使用 `serde` 定义 `ClientMessage` 和 `ServerMessage` 两个核心 `enum`，涵盖登录、发消息、用户列表等所有操作。
  2.  **实现消息分帧：** 这是关键。在 TCP 流中，必须手动界定消息边界。采用**长度前缀法**：
      - **发送**：`消息对象 -> JSON字符串 -> UTF8字节流 -> 计算长度(u32) -> 发送4字节长度 -> 发送消息字节流`。
      - **接收**：`读取4字节获取长度N -> 循环读取直到获得N字节 -> 将字节流转为JSON字符串 -> 反序列化为消息对象`。
  3.  **重构服务器**：`handle_connection` 的主循环不再处理文本行，而是接收 `ClientMessage`，并根据其类型进行分发处理，然后发送回 `ServerMessage`。

#### **第二步：构建“系统记忆” - 实现自研数据库**

在定义了清晰的数据结构（协议消息）之后，我们就可以将其持久化。

- **目标：** 实现一个简单的持久化键值存储，用于保存用户信息和历史消息。
- **行动：**
  1.  **创建新库：** `cargo new --lib toy_db`，并在主项目 `Cargo.toml` 中通过 `path` 依赖它。
  2.  **设计存储引擎：** 采用**纯追加日志（Append-only Log）**模型。
      - 所有写操作（如 `save_user`, `save_message`）被序列化（推荐使用 `bincode` 以获得高性能）后，追加写入到一个数据文件中。
      - 在内存中维护一个 `HashMap` 作为索引，Key 是`user_id`或`message_id`，Value 是该数据在文件中的字节偏移量。
  3.  **集成：** 服务器在启动时加载数据库。处理注册和消息请求时，除了在内存中操作，还异步调用数据库接口将数据写入磁盘。

#### **第三步：构建“系统探针” - 独立实现内核观测**

现在系统已经可以运行并产生数据，我们可以开始观察它的底层行为了。此阶段先独立开发观测工具。

- **目标：** 使用 eBPF 捕获聊天服务器的网络系统调用，并打印到控制台。
- **行动：**
  1.  **创建 eBPF 项目：** 使用 Aya 的模板 `cargo generate --git https://github.com/aya-rs/aya-template` 创建一个新项目，如 `observer_ebpf`。
  2.  **编写 eBPF 探针：** 在 eBPF 程序部分，使用 `#[kprobe]` 宏挂载到 `__sys_sendmsg` 和 `__sys_recvmsg` 内核函数。
  3.  **过滤与发送：** 在探针函数内，获取当前进程 PID。如果 PID 是你的聊天服务器进程，就将一些元数据（如消息大小、时间戳）通过 `PerfEventArray` 发送到用户空间。
  4.  **编写用户态加载器：** 这是一个独立的 Rust 程序，负责加载并附加 eBPF 探针到内核，然后在一个循环中从 `PerfEventArray` 读取数据并打印。你可以通过命令行参数传入聊天服务器的 PID 来启动它。

#### **第四步：整合一切 - 打造“指挥中心”仪表盘**

这是最后一步，将所有分散的能力聚合到一个统一的图形化界面中。

- **目标：** 创建一个 GUI 应用，它既是聊天客户端，也是服务器的监控仪表盘。
- **行动：**
  1.  **创建 Tauri 项目：** `cargo tauri init`。
  2.  **设计 Tauri 后端（Rust）：** 这个 Rust 后端将同时扮演两个角色：
      - **角色一：聊天客户端。** 它使用第一步定义的 JSON 协议连接到你的聊天服务器，收发消息，获取在线列表。
      - **角色二：eBPF 加载器。** 它将第三步的用户态加载器逻辑集成进来，负责加载 eBPF 探针并从内核接收数据。
  3.  **数据流整合：** Tauri 后端将从聊天服务器收到的**应用层数据**和从 eBPF 收到的**内核层数据**进行整合，并通过 Tauri 的事件系统（`window.emit`）发送给前端 UI。
  4.  **设计 UI（Web 技术）：** 使用 Vue 或 React 等框架，创建多个组件：一个用于聊天的面板，一个用于实时显示服务器指标（如在线人数、TPS）的图表，以及一个用于展示 eBPF 数据的面板（如网络 I/O 延迟直方图）。

## 涉及到的技术领域

**1. 网络编程与高并发架构**

- **核心**：基于事件驱动的异步网络编程模型。
- **技术**：Rust 的 `async/await` 生态（如 `tokio` 运行时）、TCP/UDP 协议、WebSocket 协议、连接池管理、处理 C10K 问题。

**2. 操作系统内核与系统编程**

- **核心**：深入 Linux 内核，实现极致的性能优化和深度的系统可观测性。
- **技术**：
  - **Linux I/O 模型**：从 `poll/epoll` 到最新的 `io_uring`。
  - **eBPF**：用于动态追踪和性能分析。编写 eBPF 探针（内核态）和用户态加载器，理解 BPF 虚拟机、Map、Helper Function 等概念。
  - **系统调用**：对 `sendmsg`, `recvmsg` 等网络相关系统调用的深度理解。

**3. 数据库与存储系统**

- **核心**：自研存储引擎，理解数据库的核心构造。
- **技术**：
  - **数据结构和算法**：哈希索引、B-Tree/LSM-Tree（如果实现）、跳表等。
  - **存储引擎**：日志结构合并树、追加写日志、垃圾回收。
  - **持久化与一致性**：预写日志（WAL）、检查点、ACID 属性（简易版）、崩溃恢复。

**4. 分布式系统（潜在的扩展方向）**

- **核心**：使服务从单机走向分布式，解决可扩展性和高可用性问题。
- **技术**：服务发现（etcd/ZooKeeper）、一致性哈希、数据分片、RPC 通信、分布式消息队列（Kafka/NATS）。

**5. 前端与用户界面开发**

- **核心**：构建现代化的、可交互的管理界面。
- **技术**：
  - **Rust 原生 GUI**：`egui` 或 `Iced` 框架，了解即时模式 GUI 和保留模式 GUI 的区别。
  - **Web 技术栈**：使用 `Tauri` 框架，结合 Rust 后端与 HTML/CSS/JS（或 React/Vue/Svelte）前端。

**6. 编程语言与工程实践**

- **核心**：熟练运用 Rust 语言及其独特范式。
- **技术**：
  - **Rust 高级特性**：所有权系统、生命周期、无畏并发、`async/await`、Trait 系统、FFI（与 C 库交互，如 eBPF）。
  - **开发工具链**：Cargo、测试、性能剖析（`perf`, `flamegraph`）。

---

### 总结与介绍项目

**【总结】**

> 这是一个基于 Rust 构建的、集成了 eBPF 内核级可观测性和自研存储引擎的高性能聊天平台，并配备了用于系统监控的现代化管理界面。

**【详细阐述】（可用于简历项目描述）**

- **项目概述**：
  - 独立设计并实现了一个全栈式系统，旨在探索从应用层到操作系统内核的完整技术栈。项目不仅提供了基础的实时聊天功能，更是一个用于深入理解高并发、系统编程和数据库内部机制的实验平台。
- **核心职责与技术创新**：
  1. **高性能聊天服务器**：采用 Rust 与`tokio`异步运行时，基于`epoll`事件驱动模型构建，高效处理万级并发连接，并通过自定义二进制协议优化网络传输效率。
  2. **内核级可观测性**：集成 eBPF 技术，使用`Aya`框架编写探针，动态追踪消息处理路径上的系统调用（如`sendmsg`）和内核事件，实现了对服务性能与行为的“上帝视角”监控。
  3. **自研存储引擎**：为实现消息持久化，设计并实现了一个玩具级的 KV 存储数据库，采用**追加写日志与内存哈希索引**的结构，并实现了 WAL（预写日志）机制来保证崩溃恢复。
  4. **一体化管理 GUI**：利用`Tauri`框架构建了跨平台桌面应用，前端可视化展示实时聊天数据、服务器性能指标以及 eBPF 捕获的内核级追踪信息，将系统内部状态透明化。
- **技术价值与个人收获**：
  - 通过本项目，打通了**应用层 -> 用户态 -> 内核态**的完整技术链条，获得了对计算机系统（尤其是 Linux I/O、网络、存储）第一手的、深刻的理解。
  - 将 eBPF、异步编程、数据库实现等前沿或底层技术在一个实际项目中融会贯通，展现了强大的自主技术探索和系统架构能力。
  - 该项目不仅是功能实现，更是一个极具深度的**技术演示**，证明了如何用 Rust 构建兼具高性能、安全性和可观测性的复杂系统。

**【精简版总结】（用于电梯演讲）**
“我构建了一个用 Rust 写的聊天服务器，它的独特之处在于，我集成了 eBPF 来实时观测内核级的消息流，并且为了深入理解数据库，我甚至自己写了一个简单的存储引擎来存聊天记录。最后，我还给它做了个带图表的管理界面，能实时看到系统内部的一切。”

---

<!--

## 🚀 设计路线图

### v0.1: 匿名广播中转站 (最简可行产品)

这是项目的“种子”，验证网络并发的核心。

- **特点与功能:**
  1. 服务器在指定端口（如 `127.0.0.1:8080`）监听 TCP 连接。
  2. **并发处理**：服务器能**同时**接受和处理**多个**客户端（终端）的连接。每个连接都在一个独立的异步任务中处理（`tokio::spawn`）。
  3. **消息中转**：服务器是一个消息中转站。
  4. **广播**：当 `Terminal A` 发送一条消息时，服务器会将其转发给**所有**当前连接的客户端（包括 `Terminal A` 自己）。
  5. **实时性**：所有终端会（在网络延迟允许内）立刻看到消息。
  6. **数据格式**：只能处理**以换行符 (`\n`) 分隔**的纯 UTF-8 文本行（Line-based Text）。
  7. **匿名性**：`Terminal B` 收到消息时，无法知道是 `Terminal A` 还是 `Terminal C` 发送的。
  8. **无历史记录**：服务器**不保存**任何聊天记录。消息被转发后即被丢弃。
  9. **连接状态**：服务器**只维护**一个“当前活跃连接列表”（例如，一个 `Arc<Mutex<HashMap<...>>>`），以便知道要把消息转发给谁。

---

### v0.2: “带身份的聊天室”

在 v0.1 的基础上，引入“用户”的概念。

- **特点与功能:**
  1. **协议变更**：客户端连接成功后，它发送的**第一行文本**将被服务器视为其“用户名”。
  2. **引入共享状态**：服务器的共享状态（`Arc<Mutex<...>>`）现在需要升级，用于存储“用户名”和“该用户的连接”（具体来说，是用于向该用户发消息的 `mpsc::Sender`）之间的映射。
     - `State = Arc<Mutex<HashMap<String, mpsc::Sender<String>>>>`
  3. **身份显示**：当用户 "Alice" 发送消息 "hello" 时，其他所有终端收到的消息不再是匿名的 "hello"，而是格式化的 "Alice: hello"。
  4. **唯一性检查**：当一个新用户尝试使用一个**已存在**的用户名登录时，服务器应拒绝连接，并向其发送一条错误消息，然后断开连接。
  5. **（新功能）上下线通知**：
     - 当 "Alice" 成功注册用户名后，服务器向**所有其他**已连接用户广播一条系统消息，例如：`[Server] Alice has joined.`
     - 当 "Alice" 的连接断开时，服务器从共享状态中移除 "Alice"，并向**所有剩余**用户广播：`[Server] Alice has left.`

---

### v0.3: “命令与私聊”

在 v0.2 基础上，引入一个简单的命令系统，使服务器不再是“无脑”转发。

- **特点与功能:**
  1. **引入协议解析**：服务器在收到客户端的每一行消息时，**不再**无条件地广播。
  2. **命令判断**：服务器首先检查消息是否以一个特殊字符（例如 `/`）开头。
  3. **广播逻辑**：如果消息**不**以 `/` 开头，则按 v0.2 的逻辑（带身份）进行广播。
  4. **（新功能）命令处理**：
     - **`/list`**：如果客户端发送 `/list`。服务器收到后，会**只向该客户端**回复当前所有在线用户的列表，例如：`[Server] Users online: Alice, Bob, Charlie`。
     - **`/w <username> <message>`**（私聊）：如果 "Alice" 发送 `/w Bob hello bob`。
     - 服务器解析出目标 "Bob" 和消息 "hello bob"。
     - 服务器从共享状态（`HashMap`）中查找 "Bob" 对应的 `mpsc::Sender`。
     - **私聊路由**：如果 "Bob" 存在，服务器**只**向 "Bob" 的通道发送消息，例如：`[Private from Alice] hello bob`。
     - **私聊回显**："Alice" 自己也应该收到一条确认，例如：`[Private to Bob] hello bob`。
     - **错误处理**：如果 "Bob" 不存在，服务器**只**向 "Alice" 回复一条错误消息，例如：`[Server] User 'Bob' not found.`

---

### v0.4: “结构化应用协议” (JSON)

这是一个重大的重构，为文件传输等复杂功能铺路。

- **特点与功能:**

  1. **告别行协议**：服务器和客户端**不再**使用 `read_line` 和发送纯文本。

  2. **定义消息体 (Structs/Enums)**：在代码中用 `struct` 和 `enum` 定义所有可能的消息类型。

     Rust

     ```
     // 示例
     enum ClientMessage {
         Login { username: String },
         Broadcast { content: String },
         Whisper { to: String, content: String },
     }
     enum ServerMessage {
         UserJoined { username: String },
         UserLeft { username: String },
         NewMessage { from: String, content: String },
         PrivateMessage { from: String, content: String },
         Error { msg: String },
     }
     ```

  3. **序列化/反序列化**：使用 `serde_json` 库。

     - 客户端将 `ClientMessage` 序列化为 JSON 字符串（字节流）后发送。
     - 服务器接收字节流，将其反序列化为 `ClientMessage` 枚举，然后根据类型处理。
     - 服务器将 `ServerMessage` 序列化为 JSON 字符串后发送给客户端。

  4. **（关键）消息分帧 (Message Framing)**：

     - TCP 是“流”协议，不保证一次 `read` 就能读到一个完整的 JSON。
     - 必须实现一个简单的“分帧”机制。最常用的是**“长度前缀法”**：
     - **发送方**：先计算出 JSON 字符串的**长度 N**（比如 `u32`，占 4 字节），先发送这 4 字节的长度，再发送 N 字节的 JSON 数据。
     - **接收方**：先固定读取 4 字节，解析出长度 N。然后再循环读取，直到凑够 N 字节的数据。最后才用 `serde_json` 解析这 N 字节。

  5. **功能对齐**：v0.3 的所有功能（登录、广播、私聊、列表）都用新的 JSON 消息体来重新实现。

---

### v0.5: “文件传输”

在 v0.4 的 JSON 协议基础上，实现复杂的文件收发。

- **特点与功能:**
  1. **依赖 v0.4**：必须使用 v0.4 的结构化协议来协商文件传输。
  2. **控制流 (JSON 协商)**：文件传输分为“控制流”（发 JSON）和“数据流”（发原始字节）。
     - `Alice` 向服务器发送 JSON 消息：`{"type": "FileOffer", "to": "Bob", "filename": "cat.png", "size": 123456}`。
     - 服务器收到后，将这个 `FileOffer` 消息（可以附加上 `from: "Alice"`）转发给 `Bob`。
     - `Bob` 的客户端收到后，弹窗询问是否接受。如果 `Bob` 同意，回复 JSON 消息：`{"type": "FileAccept", "from": "Alice", "filename": "cat.png"}`。
  3. **数据流 (服务器中转方案)**：
     - 服务器收到 `FileAccept`，它知道 A 和 B 已经同意。
     - 服务器向 `Alice` 发送 JSON 消息：`{"type": "StartUpload", "filename": "cat.png"}`。
     - 服务器向 `Bob` 发送 JSON 消息：`{"type": "StartDownload", "from": "Alice", "filename": "cat.png", "size": 123456}`。
  4. **（关键）连接状态机**：
     - 服务器处理 `Alice` 连接的任务，在发送 `StartUpload` 后，**立即切换状态**：从“等待 JSON 消息” 切换到 “接收文件(123456 字节)” 状态。
     - `Alice` 的客户端在收到 `StartUpload` 后，也切换到“发送文件”状态。
     - 在此状态下，服务器**不再**尝试解析 JSON，而是**直接**从 `Alice` 的 socket 接收 `123456` 字节的原始数据（`tokio::io::copy_n`），并将其**实时转发**给 `Bob` 的 socket（或者先存到服务器临时文件再转发）。
     - 传输完成后，服务器处理 `Alice` 和 `Bob` 的任务**都**切换回“等待 JSON 消息”的状态。 -->
