prompt

```sh

我已经学习了miniredis，我在它的基础上 能不能做一些自己的事情 或者说通过我在他身上学到的东西，做一个自己的东西。
我个人的想法是做一个网络服务器 无论是聊天服务器还是文件send server or combine both 总之我需要做一个网络和并发相关的东西
最好的是做一个我自己可以用的项目和一个个人手写的网络库项目



我还需要你做一件事情，通常一个工程都是从简单到复杂

也就是 比如一个最开始的服务器

他可能只有一个main,rs文件 里面有监听 也有 链接 把cline and server反在一起
然后他们的写法和性能也非常的简单

我现在就是需要一个这么简单的东西，我需要你告诉我一下的事情

1. 我这个项目能够用来做什么 比如 是这是一个 网络服务器 我 可以把他部署在公网上面 user1 连接到 web后可以发送 消息 比如 文字 文件 图片 或者别的压缩包之类的 然后接收者可以通过某种方式 选择下载或者不下载

2. 这个最简单的项目 的每个文件 用来做什么的，a调用了b call c and call d 这种调用关系需要你说清楚
3.解释每个文件 dir 的名字的用途 这个也是需要每一个人去理解的 我还需要你帮我解释很多常见的  比如utils 或者什么别的之类的
4.请你把以上整理为一个readme,md


----
也就是设计路线如下
0.1 最原始 也是最简单的版本：
他的功能
很多的终端链接到一个端口 比如 这里的 127.0.0.1 8080
我们的服务器的功能是一个消息中转站
1.他会把terminalA的消息发送给所有连接到server 的terminals
2.所有的终端会立刻看见
3.只能发送文本信息
4.服务器没有任何的记载历史消息
（我的这些记录可能缺漏，我不是在记载他的缺点 我是客观的记录他的功能和当前的特点 我没有记录的需要你补充，你补充完的文本应该和我当前这个很像，也就是5 6 7 8或者修改我的文辞有错误的地方 而不是添加一些奇怪的东西）

0.2 到后面的 帮我补充

我将描述整个程序的启动过程，我需要做到以下的要求
1.对我的描述的错误的地方进行讲解和修正
2.对我其中提出的疑问进行解释
3.结束后，帮我修正和排版我的解释，我需要一个更清晰的版本，除了专业术语 其他的尽可能使用英文

整个程序的启动过程如下

1.main对127.0.0.0:8080进行监听 使用tcplistener bind 和await 因为使用的是tokio的异步 需要使用 await进行等待

2监听success 也就是 127.0.0.0:8080 没有任何的程序使用，处于空闲状态 才会监听成功

3. 进入一个无线循环 直到遇见"ctrl+c" 结束整个程序

4.match 接入监听端口的每一个 终端
如果他们的ipadress和socket可用(这里我不知道socket是什么 用来干嘛的)

5. 然后对我的hashmap clone ，在多线程之间应用

6. 启动tokio::spwan整个多线程 把mathc到的addr socket state_clone 传入我的handle_connection函数



接下里是handle_connection function:
他又两种情况
1.发送消息给所有人
2.接收消息

这里我不知道具体的细节，需要你讲解




我这里有一个问题
我发现无论是发送消息 还是接受消息 都是客户端在处理 为什么不是服务端处理

this is tm1 msg1

```

## 🚀 设计路线图

### v0.1: 匿名广播中转站 (最简可行产品)

这是项目的“种子”，验证网络并发的核心。

- **特点与功能:**
  1. 服务器在指定端口（如 `127.0.0.1:8080`）监听 TCP 连接。
  2. **并发处理**：服务器能**同时**接受和处理**多个**客户端（终端）的连接。每个连接都在一个独立的异步任务中处理（`tokio::spawn`）。
  3. **消息中转**：服务器是一个消息中转站。
  4. **广播**：当 `Terminal A` 发送一条消息时，服务器会将其转发给**所有**当前连接的客户端（包括 `Terminal A` 自己）。
  5. **实时性**：所有终端会（在网络延迟允许内）立刻看到消息。
  6. **数据格式**：只能处理**以换行符 (`\n`) 分隔**的纯 UTF-8 文本行（Line-based Text）。
  7. **匿名性**：`Terminal B` 收到消息时，无法知道是 `Terminal A` 还是 `Terminal C` 发送的。
  8. **无历史记录**：服务器**不保存**任何聊天记录。消息被转发后即被丢弃。
  9. **连接状态**：服务器**只维护**一个“当前活跃连接列表”（例如，一个 `Arc<Mutex<HashMap<...>>>`），以便知道要把消息转发给谁。

---

### v0.2: “带身份的聊天室”

在 v0.1 的基础上，引入“用户”的概念。

- **特点与功能:**
  1. **协议变更**：客户端连接成功后，它发送的**第一行文本**将被服务器视为其“用户名”。
  2. **引入共享状态**：服务器的共享状态（`Arc<Mutex<...>>`）现在需要升级，用于存储“用户名”和“该用户的连接”（具体来说，是用于向该用户发消息的 `mpsc::Sender`）之间的映射。
     - `State = Arc<Mutex<HashMap<String, mpsc::Sender<String>>>>`
  3. **身份显示**：当用户 "Alice" 发送消息 "hello" 时，其他所有终端收到的消息不再是匿名的 "hello"，而是格式化的 "Alice: hello"。
  4. **唯一性检查**：当一个新用户尝试使用一个**已存在**的用户名登录时，服务器应拒绝连接，并向其发送一条错误消息，然后断开连接。
  5. **（新功能）上下线通知**：
     - 当 "Alice" 成功注册用户名后，服务器向**所有其他**已连接用户广播一条系统消息，例如：`[Server] Alice has joined.`
     - 当 "Alice" 的连接断开时，服务器从共享状态中移除 "Alice"，并向**所有剩余**用户广播：`[Server] Alice has left.`

---

### v0.3: “命令与私聊”

在 v0.2 基础上，引入一个简单的命令系统，使服务器不再是“无脑”转发。

- **特点与功能:**
  1. **引入协议解析**：服务器在收到客户端的每一行消息时，**不再**无条件地广播。
  2. **命令判断**：服务器首先检查消息是否以一个特殊字符（例如 `/`）开头。
  3. **广播逻辑**：如果消息**不**以 `/` 开头，则按 v0.2 的逻辑（带身份）进行广播。
  4. **（新功能）命令处理**：
     - **`/list`**：如果客户端发送 `/list`。服务器收到后，会**只向该客户端**回复当前所有在线用户的列表，例如：`[Server] Users online: Alice, Bob, Charlie`。
     - **`/w <username> <message>`**（私聊）：如果 "Alice" 发送 `/w Bob hello bob`。
     - 服务器解析出目标 "Bob" 和消息 "hello bob"。
     - 服务器从共享状态（`HashMap`）中查找 "Bob" 对应的 `mpsc::Sender`。
     - **私聊路由**：如果 "Bob" 存在，服务器**只**向 "Bob" 的通道发送消息，例如：`[Private from Alice] hello bob`。
     - **私聊回显**："Alice" 自己也应该收到一条确认，例如：`[Private to Bob] hello bob`。
     - **错误处理**：如果 "Bob" 不存在，服务器**只**向 "Alice" 回复一条错误消息，例如：`[Server] User 'Bob' not found.`

---

### v0.4: “结构化应用协议” (JSON)

这是一个重大的重构，为文件传输等复杂功能铺路。

- **特点与功能:**

  1. **告别行协议**：服务器和客户端**不再**使用 `read_line` 和发送纯文本。

  2. **定义消息体 (Structs/Enums)**：在代码中用 `struct` 和 `enum` 定义所有可能的消息类型。

     Rust

     ```
     // 示例
     enum ClientMessage {
         Login { username: String },
         Broadcast { content: String },
         Whisper { to: String, content: String },
     }
     enum ServerMessage {
         UserJoined { username: String },
         UserLeft { username: String },
         NewMessage { from: String, content: String },
         PrivateMessage { from: String, content: String },
         Error { msg: String },
     }
     ```

  3. **序列化/反序列化**：使用 `serde_json` 库。

     - 客户端将 `ClientMessage` 序列化为 JSON 字符串（字节流）后发送。
     - 服务器接收字节流，将其反序列化为 `ClientMessage` 枚举，然后根据类型处理。
     - 服务器将 `ServerMessage` 序列化为 JSON 字符串后发送给客户端。

  4. **（关键）消息分帧 (Message Framing)**：

     - TCP 是“流”协议，不保证一次 `read` 就能读到一个完整的 JSON。
     - 必须实现一个简单的“分帧”机制。最常用的是**“长度前缀法”**：
     - **发送方**：先计算出 JSON 字符串的**长度 N**（比如 `u32`，占 4 字节），先发送这 4 字节的长度，再发送 N 字节的 JSON 数据。
     - **接收方**：先固定读取 4 字节，解析出长度 N。然后再循环读取，直到凑够 N 字节的数据。最后才用 `serde_json` 解析这 N 字节。

  5. **功能对齐**：v0.3 的所有功能（登录、广播、私聊、列表）都用新的 JSON 消息体来重新实现。

---

### v0.5: “文件传输”

在 v0.4 的 JSON 协议基础上，实现复杂的文件收发。

- **特点与功能:**
  1. **依赖 v0.4**：必须使用 v0.4 的结构化协议来协商文件传输。
  2. **控制流 (JSON 协商)**：文件传输分为“控制流”（发 JSON）和“数据流”（发原始字节）。
     - `Alice` 向服务器发送 JSON 消息：`{"type": "FileOffer", "to": "Bob", "filename": "cat.png", "size": 123456}`。
     - 服务器收到后，将这个 `FileOffer` 消息（可以附加上 `from: "Alice"`）转发给 `Bob`。
     - `Bob` 的客户端收到后，弹窗询问是否接受。如果 `Bob` 同意，回复 JSON 消息：`{"type": "FileAccept", "from": "Alice", "filename": "cat.png"}`。
  3. **数据流 (服务器中转方案)**：
     - 服务器收到 `FileAccept`，它知道 A 和 B 已经同意。
     - 服务器向 `Alice` 发送 JSON 消息：`{"type": "StartUpload", "filename": "cat.png"}`。
     - 服务器向 `Bob` 发送 JSON 消息：`{"type": "StartDownload", "from": "Alice", "filename": "cat.png", "size": 123456}`。
  4. **（关键）连接状态机**：
     - 服务器处理 `Alice` 连接的任务，在发送 `StartUpload` 后，**立即切换状态**：从“等待 JSON 消息” 切换到 “接收文件(123456 字节)” 状态。
     - `Alice` 的客户端在收到 `StartUpload` 后，也切换到“发送文件”状态。
     - 在此状态下，服务器**不再**尝试解析 JSON，而是**直接**从 `Alice` 的 socket 接收 `123456` 字节的原始数据（`tokio::io::copy_n`），并将其**实时转发**给 `Bob` 的 socket（或者先存到服务器临时文件再转发）。
     - 传输完成后，服务器处理 `Alice` 和 `Bob` 的任务**都**切换回“等待 JSON 消息”的状态。
